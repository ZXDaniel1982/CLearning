; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\diskio.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\diskio.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=870 -I..\..\Libraries\CMSIS\Include -I..\..\Libraries\CMSIS\Device\ST\STM32F4xx\Include -I..\..\Libraries\STM32F4xx_StdPeriph_Driver\inc -I..\..\User\bsp_stm32f4xx\inc -I..\..\User\bsp_stm32f4xx -I..\..\User -I..\..\User\fonts -I..\..\fatfs\src -D__MICROLIB -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DSTM32F40XX --omf_browse=.\flash\obj\diskio.crf ..\..\fatfs\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;25     /*-------------------------------------------------------------------------------------------*/
;;;26     DSTATUS disk_initialize (
000000  b570              PUSH     {r4-r6,lr}
;;;27     	BYTE pdrv				/* Physical drive nmuber (0..) */
;;;28     )
;;;29     {
000002  4604              MOV      r4,r0
;;;30     	DSTATUS stat = STA_NOINIT;
000004  2501              MOVS     r5,#1
;;;31     
;;;32     	switch (pdrv)
000006  b124              CBZ      r4,|L1.18|
000008  2c03              CMP      r4,#3
00000a  d009              BEQ      |L1.32|
00000c  2c04              CMP      r4,#4
00000e  d109              BNE      |L1.36|
000010  e007              B        |L1.34|
                  |L1.18|
;;;33     	{
;;;34     		case FS_SD :		/* SD卡 */
;;;35     			if (SD_Init() == SD_OK)
000012  f7fffffe          BL       SD_Init
000016  b908              CBNZ     r0,|L1.28|
;;;36     			{
;;;37     				stat = RES_OK;
000018  2500              MOVS     r5,#0
00001a  e000              B        |L1.30|
                  |L1.28|
;;;38     			}
;;;39     			else
;;;40     			{
;;;41     				stat = STA_NODISK;
00001c  2502              MOVS     r5,#2
                  |L1.30|
;;;42     			}
;;;43     			break;
00001e  e002              B        |L1.38|
                  |L1.32|
;;;44     //		case FS_NAND :		/* NAND Flash */
;;;45     //			if (NAND_Init() == NAND_OK)
;;;46     //			{
;;;47     //				stat = RES_OK;
;;;48     //			}
;;;49     //			else
;;;50     //			{
;;;51     //				/* ???????,???????? */
;;;52     //				printf("NAND_Init() Error!  \r\n");
;;;53     //				stat = RES_ERROR;
;;;54     //			}
;;;55     //			break;
;;;56     		case FS_SPI :		/* SPI Flash */
;;;57     		
;;;58     			break;
000020  e001              B        |L1.38|
                  |L1.34|
;;;59     
;;;60     		case FS_NOR :		/* NOR Flash */
;;;61     		
;;;62     			break;
000022  e000              B        |L1.38|
                  |L1.36|
;;;63     
;;;64     		default :
;;;65     			break;
000024  bf00              NOP      
                  |L1.38|
000026  bf00              NOP                            ;43
;;;66     	}
;;;67     
;;;68     	return stat;
000028  4628              MOV      r0,r5
;;;69     }
00002a  bd70              POP      {r4-r6,pc}
;;;70     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=1

                  disk_ioctl PROC
;;;253    #if _USE_IOCTL
;;;254    DRESULT disk_ioctl (
000000  b510              PUSH     {r4,lr}
;;;255    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;256    	BYTE cmd,		/* Control code */
;;;257    	void *buff		/* Buffer to send/receive control data */
;;;258    )
;;;259    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;260    	DRESULT res;
;;;261    
;;;262    	switch (pdrv) {
000006  b123              CBZ      r3,|L2.18|
000008  2b03              CMP      r3,#3
00000a  d005              BEQ      |L2.24|
00000c  2b04              CMP      r3,#4
00000e  d105              BNE      |L2.28|
000010  e003              B        |L2.26|
                  |L2.18|
;;;263    	case FS_SD :
;;;264    		/* SD卡磁盘容量： SDCardInfo.CardCapacity */
;;;265    		res = RES_OK;
000012  2100              MOVS     r1,#0
;;;266    		return res;
000014  4608              MOV      r0,r1
                  |L2.22|
;;;267    
;;;268    //	case FS_NAND :
;;;269    //		{
;;;270    //			DRESULT res = RES_OK;
;;;271    
;;;272    //			res = RES_ERROR;
;;;273    //			switch (cmd)
;;;274    //			{
;;;275    //				case CTRL_SYNC :		/* Make sure that no pending write process */
;;;276    //					res = RES_OK;
;;;277    //					break;
;;;278    
;;;279    //				case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
;;;280    //					*(DWORD*)buff = 200000;//262144
;;;281    //					res = RES_OK;
;;;282    //					break;
;;;283    
;;;284    //				case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
;;;285    //					*(WORD*)buff = 512;
;;;286    //					res = RES_OK;
;;;287    //					break;
;;;288    
;;;289    //				case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
;;;290    //					*(DWORD*)buff = 512;
;;;291    //					res = RES_OK;
;;;292    //					break;
;;;293    
;;;294    //				default:
;;;295    //					res = RES_PARERR;
;;;296    //					break;
;;;297    //			}
;;;298    //			return res;			
;;;299    //		}
;;;300    
;;;301    	case FS_SPI :		/* SPI Flash */
;;;302    	
;;;303    		break;
;;;304    
;;;305    	case FS_NOR :		/* NOR Flash */
;;;306    	
;;;307    		break;
;;;308    	}
;;;309    
;;;310    	return RES_PARERR;
;;;311    }
000016  bd10              POP      {r4,pc}
                  |L2.24|
000018  e000              B        |L2.28|
                  |L2.26|
00001a  bf00              NOP                            ;307
                  |L2.28|
00001c  bf00              NOP                            ;303
00001e  2004              MOVS     r0,#4                 ;310
000020  e7f9              B        |L2.22|
;;;312    #endif
                          ENDP


                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;103    /*-------------------------------------------------------------------------------------------*/
;;;104    DRESULT disk_read (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;105    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;106    	BYTE *buff,		/* Data buffer to store read data */
;;;107    	DWORD sector,	/* Sector address (LBA) */
;;;108    	UINT count		/* Number of sectors to read (1..128) */
;;;109    )
;;;110    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  4698              MOV      r8,r3
;;;111    	DRESULT res;
;;;112    
;;;113    	switch (pdrv)
00000c  b126              CBZ      r6,|L3.24|
00000e  2e03              CMP      r6,#3
000010  d02b              BEQ      |L3.106|
000012  2e04              CMP      r6,#4
000014  d12b              BNE      |L3.110|
000016  e029              B        |L3.108|
                  |L3.24|
;;;114    	{
;;;115    		case FS_SD :
;;;116    		{
;;;117    			SD_Error Status = SD_OK;
000018  f04f0900          MOV      r9,#0
;;;118    
;;;119    			if (count == 1)
00001c  f1b80f01          CMP      r8,#1
000020  d107              BNE      |L3.50|
;;;120    			{
;;;121    				Status = SD_ReadBlock(buff, sector << 9 , SECTOR_SIZE);
000022  0269              LSLS     r1,r5,#9
000024  f44f7200          MOV      r2,#0x200
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       SD_ReadBlock
00002e  4681              MOV      r9,r0
000030  e007              B        |L3.66|
                  |L3.50|
;;;122    			}
;;;123    			else
;;;124    			{
;;;125    				Status = SD_ReadMultiBlocks(buff, sector << 9 , SECTOR_SIZE, count);
000032  0269              LSLS     r1,r5,#9
000034  4643              MOV      r3,r8
000036  f44f7200          MOV      r2,#0x200
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       SD_ReadMultiBlocks
000040  4681              MOV      r9,r0
                  |L3.66|
;;;126    			}
;;;127    			if (Status != SD_OK)
000042  f1b90f00          CMP      r9,#0
000046  d001              BEQ      |L3.76|
;;;128    			{
;;;129    				res = RES_ERROR;
000048  2401              MOVS     r4,#1
;;;130    				break;
00004a  e011              B        |L3.112|
                  |L3.76|
;;;131    			}
;;;132    
;;;133    		#ifdef SD_DMA_MODE
;;;134    			/* SDIO工作在DMA模式，需要检查操作DMA传输是否完成 */
;;;135    			Status = SD_WaitReadOperation();
00004c  f7fffffe          BL       SD_WaitReadOperation
000050  4681              MOV      r9,r0
;;;136    			if (Status != SD_OK)
000052  f1b90f00          CMP      r9,#0
000056  d001              BEQ      |L3.92|
;;;137    			{
;;;138    				res = RES_ERROR;
000058  2401              MOVS     r4,#1
;;;139    				break;
00005a  e009              B        |L3.112|
                  |L3.92|
;;;140    			}
;;;141    
;;;142    			while(SD_GetStatus() != SD_TRANSFER_OK);
00005c  bf00              NOP      
                  |L3.94|
00005e  f7fffffe          BL       SD_GetStatus
000062  2800              CMP      r0,#0
000064  d1fb              BNE      |L3.94|
;;;143    		#endif
;;;144    
;;;145    			res = RES_OK;
000066  2400              MOVS     r4,#0
;;;146    			break;
000068  e002              B        |L3.112|
                  |L3.106|
;;;147    		}
;;;148    //		case FS_NAND :
;;;149    //			if (NAND_OK == NAND_ReadMultiSectors(buff, sector, 512, count))
;;;150    //			{
;;;151    //				res = RES_OK;
;;;152    //			}
;;;153    //			else
;;;154    //			{
;;;155    //				printf("NAND_ReadMultiSectors() Error! sector = %d, count = %d \r\n", sector, count);
;;;156    //				res = RES_ERROR;
;;;157    //			}
;;;158    //			break;
;;;159    		case FS_SPI :		/* SPI Flash */
;;;160    		
;;;161    			break;
00006a  e001              B        |L3.112|
                  |L3.108|
;;;162    
;;;163    		case FS_NOR :		/* NOR Flash */
;;;164    		
;;;165    			break;
00006c  e000              B        |L3.112|
                  |L3.110|
;;;166    
;;;167    		default:
;;;168    	
;;;169    			break;
00006e  bf00              NOP      
                  |L3.112|
000070  bf00              NOP                            ;130
;;;170    	}
;;;171    	return res;
000072  4620              MOV      r0,r4
;;;172    }
000074  e8bd87f0          POP      {r4-r10,pc}
;;;173    
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;73     /*-------------------------------------------------------------------------------------------*/
;;;74     DSTATUS disk_status (
000000  4601              MOV      r1,r0
;;;75     	BYTE pdrv		/* Physical drive nmuber (0..) */
;;;76     )
;;;77     {
;;;78     	DSTATUS stat = STA_NOINIT;
000002  2001              MOVS     r0,#1
;;;79     
;;;80     	switch (pdrv)
000004  b121              CBZ      r1,|L4.16|
000006  2903              CMP      r1,#3
000008  d004              BEQ      |L4.20|
00000a  2904              CMP      r1,#4
00000c  d106              BNE      |L4.28|
00000e  e003              B        |L4.24|
                  |L4.16|
;;;81     	{
;;;82     		case FS_SD :
;;;83     			stat = 0;
000010  2000              MOVS     r0,#0
;;;84     			break;
000012  e005              B        |L4.32|
                  |L4.20|
;;;85     
;;;86     		case FS_SPI :		/* SPI Flash */
;;;87     			stat = 0;
000014  2000              MOVS     r0,#0
;;;88     			break;
000016  e003              B        |L4.32|
                  |L4.24|
;;;89     
;;;90     		case FS_NOR :		/* NOR Flash */
;;;91     			stat = 0;
000018  2000              MOVS     r0,#0
;;;92     			break;
00001a  e001              B        |L4.32|
                  |L4.28|
;;;93     
;;;94     		default:
;;;95     			stat = 0;
00001c  2000              MOVS     r0,#0
;;;96     			break;
00001e  bf00              NOP      
                  |L4.32|
000020  bf00              NOP                            ;84
;;;97     	}
;;;98     	return stat;
;;;99     }
000022  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;177    #if _USE_WRITE
;;;178    DRESULT disk_write (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;179    	BYTE pdrv,			/* Physical drive nmuber (0..) */
;;;180    	const BYTE *buff,	/* Data to be written */
;;;181    	DWORD sector,		/* Sector address (LBA) */
;;;182    	UINT count			/* Number of sectors to write (1..128) */
;;;183    )
;;;184    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
00000a  4698              MOV      r8,r3
;;;185     DRESULT res;
;;;186    
;;;187    	switch (pdrv)
00000c  b126              CBZ      r6,|L5.24|
00000e  2e03              CMP      r6,#3
000010  d02e              BEQ      |L5.112|
000012  2e04              CMP      r6,#4
000014  d12e              BNE      |L5.116|
000016  e02c              B        |L5.114|
                  |L5.24|
;;;188    	{
;;;189    		case FS_SD :
;;;190    			{
;;;191    				SD_Error Status = SD_OK;
000018  f04f0900          MOV      r9,#0
;;;192    	
;;;193    				if (count == 1) 
00001c  f1b80f01          CMP      r8,#1
000020  d107              BNE      |L5.50|
;;;194    				{
;;;195    					Status = SD_WriteBlock((uint8_t *)buff, sector << 9 ,SECTOR_SIZE);
000022  0261              LSLS     r1,r4,#9
000024  f44f7200          MOV      r2,#0x200
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       SD_WriteBlock
00002e  4681              MOV      r9,r0
000030  e007              B        |L5.66|
                  |L5.50|
;;;196    				} 
;;;197    				else 
;;;198    				{
;;;199    					Status = SD_WriteMultiBlocks((uint8_t *)buff, sector << 9 ,SECTOR_SIZE, count);	
000032  0261              LSLS     r1,r4,#9
000034  4643              MOV      r3,r8
000036  f44f7200          MOV      r2,#0x200
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       SD_WriteMultiBlocks
000040  4681              MOV      r9,r0
                  |L5.66|
;;;200    				}
;;;201    				if (Status != SD_OK) 
000042  f1b90f00          CMP      r9,#0
000046  d000              BEQ      |L5.74|
;;;202    				{
;;;203    					res =  RES_ERROR;
000048  2501              MOVS     r5,#1
                  |L5.74|
;;;204    				}
;;;205    			
;;;206    			#ifdef SD_DMA_MODE	
;;;207    				/* SDIO工作在DMA模式，需要检查操作DMA传输是否完成 */
;;;208    				Status = SD_WaitReadOperation();
00004a  f7fffffe          BL       SD_WaitReadOperation
00004e  4681              MOV      r9,r0
;;;209    				if (Status != SD_OK) 
000050  f1b90f00          CMP      r9,#0
000054  d000              BEQ      |L5.88|
;;;210    				{
;;;211    					res =  RES_ERROR;
000056  2501              MOVS     r5,#1
                  |L5.88|
;;;212    				}
;;;213    				
;;;214    				while(SD_GetStatus() != SD_TRANSFER_OK);
000058  bf00              NOP      
                  |L5.90|
00005a  f7fffffe          BL       SD_GetStatus
00005e  2800              CMP      r0,#0
000060  d1fb              BNE      |L5.90|
;;;215    			#endif	
;;;216    	
;;;217    				while(SD_GetStatus() != SD_TRANSFER_OK);
000062  bf00              NOP      
                  |L5.100|
000064  f7fffffe          BL       SD_GetStatus
000068  2800              CMP      r0,#0
00006a  d1fb              BNE      |L5.100|
;;;218    	
;;;219    				res =  RES_OK;
00006c  2500              MOVS     r5,#0
;;;220    				break;
00006e  e003              B        |L5.120|
                  |L5.112|
;;;221    			}
;;;222    //		case FS_NAND :
;;;223    //			if (NAND_OK == NAND_WriteMultiSectors((uint8_t *)buff, sector, 512, count))
;;;224    //			{
;;;225    //				res = RES_OK;
;;;226    //			}
;;;227    //			else
;;;228    //			{
;;;229    //				printf("NAND_WriteMultiSectors() Error! sector = %d, count = %d \r\n", sector, count);
;;;230    //				res = RES_ERROR;
;;;231    //			}
;;;232    //			break;
;;;233    		case FS_SPI :		/* SPI Flash */
;;;234    		
;;;235    			break;
000070  e002              B        |L5.120|
                  |L5.114|
;;;236    
;;;237    		case FS_NOR :		/* NOR Flash */
;;;238    		
;;;239    			break;
000072  e001              B        |L5.120|
                  |L5.116|
;;;240    
;;;241    		default:
;;;242    			res = RES_PARERR;
000074  2504              MOVS     r5,#4
;;;243    			break;
000076  bf00              NOP      
                  |L5.120|
000078  bf00              NOP                            ;220
;;;244    	}
;;;245    	return res;
00007a  4628              MOV      r0,r5
;;;246    }
00007c  e8bd87f0          POP      {r4-r10,pc}
;;;247    #endif
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=2

                  get_fattime PROC
;;;321    */
;;;322    DWORD get_fattime (void)
000000  4800              LDR      r0,|L6.4|
;;;323    {
;;;324    	/* 如果有全局时钟，可按下面的格式进行时钟转换. 这个例子是2013-01-01 00:00:00 */
;;;325    
;;;326    	return	  ((DWORD)(2013 - 1980) << 25)	/* Year = 2013 */
;;;327    			| ((DWORD)1 << 21)				/* Month = 1 */
;;;328    			| ((DWORD)1 << 16)				/* Day_m = 1*/
;;;329    			| ((DWORD)0 << 11)				/* Hour = 0 */
;;;330    			| ((DWORD)0 << 5)				/* Min = 0 */
;;;331    			| ((DWORD)0 >> 1);				/* Sec = 0 */
;;;332    }
000002  4770              BX       lr
                          ENDP

                  |L6.4|
                          DCD      0x42210000

;*** Start embedded assembler ***

#line 1 "..\\..\\fatfs\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REV16|
#line 129 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_diskio_c_b3252454____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REVSH|
#line 144
|__asm___8_diskio_c_b3252454____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
