#include "stm32f1xx.h"
#include "stm32f103xe.h"
#include "common.h"

static void Error_Handler(void)
{

}

static void RCC_Init(void)
{
    __IO uint32_t tmpreg;
    // 辅助功能IO时钟使能
    SET_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
    /* Delay after an RCC peripheral clock enabling */
    tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
    (void)tmpreg;

    // 电源接口时钟使能
    // If you don't set the RCC_APB1ENR .PWREN bit,
    // the registers of PWR unit can't be written and reading them returns 0.
    SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
    /* Delay after an RCC peripheral clock enabling */
    tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
    (void)tmpreg;

    NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);

    // 通用和复用功能I/O
    CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);  // 000：完全SWJ(JTAG-DP + SW-DP)：复位状态；
    SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_DISABLE); // 100：关闭JTAG-DP，关闭SW-DP；

    // 010：两个等待状态，当 48MHz < SYSCLK ≤ 72MHz
    MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, FLASH_ACR_LATENCY_1);
    if((uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY)) != FLASH_ACR_LATENCY_1) {
        Error_Handler();  
    }

    // 外部高速时钟使能
    // 1： HSE振荡器开启
    SET_BIT(RCC->CR, RCC_CR_HSEON);
    while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RCC_CR_HSERDY);

    // PLL输入时钟源  1： PREDIV1输出作为PLL输入时钟
    // PREDIV1分频因子的低位  置0
    // PLL倍频系数  0111： PLL 9倍频输出
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
             (RCC_CFGR_PLLSRC & (RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE)) | RCC_CFGR_PLLMULL9);

    // 1： PLL使能。
    SET_BIT(RCC->CR, RCC_CR_PLLON);
    while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RCC_CR_PLLRDY);

    // AHB预分频  0xxx： SYSCLK不分频
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_CFGR_HPRE_DIV1);
    // 低速APB预分频   100： HCLK 2分频
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV2);
    // 高速APB预分频   0xx： HCLK不分频
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_CFGR_PPRE2_DIV1);
    // 系统时钟切换    10： PLL输出作为系统时钟；
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);
    while((uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS)) != RCC_CFGR_SWS_PLL);


    SysTick->LOAD  = (uint32_t)((72000000 / 1000U) - 1UL);  // 倒数到0， 重新装载
    SysTick->VAL   = 0UL;   // current值  写入清0
    SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |      // 1 : 内核时钟源 FCLK
                    SysTick_CTRL_ENABLE_Msk;  // 定时器使能


    SET_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
    SystemCoreClock = 72000000;
} 

static void TIMER_Init(TIM_TypeDef *TIMx, uint32_t Periphs, IRQn_Type IRQn)
{
	/*
		SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);
		NVIC_SetPriority(TIM2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
    NVIC_EnableIRQ(TIM2_IRQn);

    WRITE_REG(TIM2->ARR, 2000-(TIM_CCMR1_IC1F_0 << 16U));
    WRITE_REG(TIM2->PSC, 36000-(TIM_CCMR1_IC1F_0 << 16U));

    //tftprintf("EGR %08x", TIM2->EGR);
    //SET_BIT(TIMx->EGR, TIM_EGR_UG);
    //tftprintf("EGR %08x", TIM2->EGR);

    CLEAR_BIT(TIM2->CR1, TIM_CR1_OPM);
    SET_BIT(TIM2->CR1, TIM_CR1_URS);
	  CLEAR_BIT(TIM2->SMCR, TIM_SMCR_MSM);

    SET_BIT(TIM2->DIER, TIM_DIER_UIE);

    SET_BIT(TIM2->CR1, TIM_CR1_CEN);*/
	//开启基本定时器6（TIM6）的时钟
		SET_BIT(RCC->APB1ENR, Periphs);
 
    /*清空计数器的值*/
    WRITE_REG(TIMx->CNT, 0);
    WRITE_REG(TIMx->ARR, 2000-(TIM_CCMR1_IC1F_0 << 16U));
    WRITE_REG(TIMx->PSC, 36000-(TIM_CCMR1_IC1F_0 << 16U));

    WRITE_REG(TIMx->CR1, 0); //将控制寄存器1清空

    SET_BIT(TIMx->CR1, TIM_CR1_URS); //设置事件更新请求源

    /*设置无缓冲功能*/
    CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);

    /*设置循环模式*/
    CLEAR_BIT(TIMx->CR1, TIM_CR1_OPM);

    /*允许更新中断使能*/
    SET_BIT(TIMx->DIER, TIM_DIER_UIE);

    /*使能基本定时器中断*/
    NVIC_EnableIRQ(IRQn);

    /*开启计数器使能*/
    SET_BIT(TIMx->CR1, TIM_CR1_CEN);

}

int main()
{
	  uint8_t buf = 0;
	
	  RCC_Init();
    GPIO_Init();
	  USART_Init();
	  TIMER_Init(TIM2, RCC_APB1ENR_TIM2EN, TIM2_IRQn);
	
    while(1) {
				if((USART1->SR & USART_CR1_RXNEIE) != 0) {
				    buf = USART1->DR;
					  USART_RxProcess(buf);
				}
		}
}

void TIM2_IRQHandler(void)
{
    static uint8_t flag = 0;
		if(TIM2->SR & (1<<0))      //溢出中断
    {
        TIM2->SR &= ~(1<<0);  //清除中断标志位
        //执行相应操作
        if (flag) {
						flag = 0;
						MODIFY_REG(Led_GPIO_Port->ODR, Led_Pin, Led_Pin);
				} else {
						MODIFY_REG(Led_GPIO_Port->ODR, Led_Pin, 0);
						flag = 1;
				}
    }


}
