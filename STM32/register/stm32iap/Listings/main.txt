; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\main.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Core\Inc -IC:\workspace\CLearning\STM32\register\stm32iap\RTE\_stm32iap -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DSTM32F10X_HD -DSTM32F103xE --omf_browse=.\objects\main.crf Core\Src\main.c]
                          THUMB

                          AREA ||i.Error_Handler||, CODE, READONLY, ALIGN=1

                  Error_Handler PROC
;;;4      
;;;5      static void Error_Handler(void)
000000  4770              BX       lr
;;;6      {
;;;7      
;;;8      }
;;;9      
                          ENDP


                          AREA ||i.RCC_Init||, CODE, READONLY, ALIGN=2

                  RCC_Init PROC
;;;9      
;;;10     static void RCC_Init(void)
000000  b508              PUSH     {r3,lr}
;;;11     {
;;;12         __IO uint32_t tmpreg;
;;;13         // 辅助功能IO时钟使能
;;;14         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
000002  4849              LDR      r0,|L2.296|
000004  6980              LDR      r0,[r0,#0x18]
000006  f0400001          ORR      r0,r0,#1
00000a  4947              LDR      r1,|L2.296|
00000c  6188              STR      r0,[r1,#0x18]
;;;15         /* Delay after an RCC peripheral clock enabling */
;;;16         tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
00000e  4608              MOV      r0,r1
000010  6980              LDR      r0,[r0,#0x18]
000012  f0000001          AND      r0,r0,#1
000016  9000              STR      r0,[sp,#0]
;;;17         (void)tmpreg;
000018  bf00              NOP      
;;;18     
;;;19         // 电源接口时钟使能
;;;20         // If you don't set the RCC_APB1ENR .PWREN bit,
;;;21         // the registers of PWR unit can't be written and reading them returns 0.
;;;22         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
00001a  4608              MOV      r0,r1
00001c  69c0              LDR      r0,[r0,#0x1c]
00001e  f0405080          ORR      r0,r0,#0x10000000
000022  61c8              STR      r0,[r1,#0x1c]
;;;23         /* Delay after an RCC peripheral clock enabling */
;;;24         tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
000024  4608              MOV      r0,r1
000026  69c0              LDR      r0,[r0,#0x1c]
000028  f0005080          AND      r0,r0,#0x10000000
00002c  9000              STR      r0,[sp,#0]
;;;25         (void)tmpreg;
00002e  bf00              NOP      
;;;26     
;;;27         NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
000030  2003              MOVS     r0,#3
000032  4602              MOV      r2,r0
000034  4b3d              LDR      r3,|L2.300|
000036  6819              LDR      r1,[r3,#0]
000038  f64f03ff          MOV      r3,#0xf8ff
00003c  4019              ANDS     r1,r1,r3
00003e  4b3c              LDR      r3,|L2.304|
000040  430b              ORRS     r3,r3,r1
000042  ea432102          ORR      r1,r3,r2,LSL #8
000046  4b39              LDR      r3,|L2.300|
000048  6019              STR      r1,[r3,#0]
00004a  bf00              NOP      
;;;28     
;;;29         // 通用和复用功能I/O
;;;30         CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);  // 000：完全SWJ(JTAG-DP + SW-DP)：复位状态；
00004c  4839              LDR      r0,|L2.308|
00004e  6840              LDR      r0,[r0,#4]
000050  f02060e0          BIC      r0,r0,#0x7000000
000054  4937              LDR      r1,|L2.308|
000056  6048              STR      r0,[r1,#4]
;;;31         SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_DISABLE); // 100：关闭JTAG-DP，关闭SW-DP；
000058  4608              MOV      r0,r1
00005a  6840              LDR      r0,[r0,#4]
00005c  f0406080          ORR      r0,r0,#0x4000000
000060  6048              STR      r0,[r1,#4]
;;;32     
;;;33         // 010：两个等待状态，当 48MHz < SYSCLK ≤ 72MHz
;;;34         MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, FLASH_ACR_LATENCY_1);
000062  4835              LDR      r0,|L2.312|
000064  6800              LDR      r0,[r0,#0]
000066  f0200007          BIC      r0,r0,#7
00006a  1c80              ADDS     r0,r0,#2
00006c  4932              LDR      r1,|L2.312|
00006e  6008              STR      r0,[r1,#0]
;;;35         if((uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY)) != FLASH_ACR_LATENCY_1) {
000070  4608              MOV      r0,r1
000072  6800              LDR      r0,[r0,#0]
000074  f0000007          AND      r0,r0,#7
000078  2802              CMP      r0,#2
00007a  d001              BEQ      |L2.128|
;;;36             Error_Handler();  
00007c  f7fffffe          BL       Error_Handler
                  |L2.128|
;;;37         }
;;;38     
;;;39         // 外部高速时钟使能
;;;40         // 1： HSE振荡器开启
;;;41         SET_BIT(RCC->CR, RCC_CR_HSEON);
000080  4829              LDR      r0,|L2.296|
000082  6800              LDR      r0,[r0,#0]
000084  f4403080          ORR      r0,r0,#0x10000
000088  4927              LDR      r1,|L2.296|
00008a  6008              STR      r0,[r1,#0]
;;;42         while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RCC_CR_HSERDY);
00008c  bf00              NOP      
                  |L2.142|
00008e  4826              LDR      r0,|L2.296|
000090  6800              LDR      r0,[r0,#0]
000092  f4003000          AND      r0,r0,#0x20000
000096  f5b03f00          CMP      r0,#0x20000
00009a  d1f8              BNE      |L2.142|
;;;43     
;;;44         // PLL输入时钟源  1： PREDIV1输出作为PLL输入时钟
;;;45         // PREDIV1分频因子的低位  置0
;;;46         // PLL倍频系数  0111： PLL 9倍频输出
;;;47         MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
00009c  4822              LDR      r0,|L2.296|
00009e  6840              LDR      r0,[r0,#4]
0000a0  f420107c          BIC      r0,r0,#0x3f0000
0000a4  f44010e8          ORR      r0,r0,#0x1d0000
0000a8  491f              LDR      r1,|L2.296|
0000aa  6048              STR      r0,[r1,#4]
;;;48                  (RCC_CFGR_PLLSRC & (RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE)) | RCC_CFGR_PLLMULL9);
;;;49     
;;;50         // 1： PLL使能。
;;;51         SET_BIT(RCC->CR, RCC_CR_PLLON);
0000ac  4608              MOV      r0,r1
0000ae  6800              LDR      r0,[r0,#0]
0000b0  f0407080          ORR      r0,r0,#0x1000000
0000b4  6008              STR      r0,[r1,#0]
;;;52         while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RCC_CR_PLLRDY);
0000b6  bf00              NOP      
                  |L2.184|
0000b8  481b              LDR      r0,|L2.296|
0000ba  6800              LDR      r0,[r0,#0]
0000bc  f0007000          AND      r0,r0,#0x2000000
0000c0  f1b07f00          CMP      r0,#0x2000000
0000c4  d1f8              BNE      |L2.184|
;;;53     
;;;54         // AHB预分频  0xxx： SYSCLK不分频
;;;55         MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_CFGR_HPRE_DIV1);
0000c6  4818              LDR      r0,|L2.296|
0000c8  6840              LDR      r0,[r0,#4]
0000ca  f02000f0          BIC      r0,r0,#0xf0
0000ce  4916              LDR      r1,|L2.296|
0000d0  6048              STR      r0,[r1,#4]
;;;56         // 低速APB预分频   100： HCLK 2分频
;;;57         MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV2);
0000d2  4608              MOV      r0,r1
0000d4  6840              LDR      r0,[r0,#4]
0000d6  f42060e0          BIC      r0,r0,#0x700
0000da  f4406080          ORR      r0,r0,#0x400
0000de  6048              STR      r0,[r1,#4]
;;;58         // 高速APB预分频   0xx： HCLK不分频
;;;59         MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_CFGR_PPRE2_DIV1);
0000e0  4608              MOV      r0,r1
0000e2  6840              LDR      r0,[r0,#4]
0000e4  f4205060          BIC      r0,r0,#0x3800
0000e8  6048              STR      r0,[r1,#4]
;;;60         // 系统时钟切换    10： PLL输出作为系统时钟；
;;;61         MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);
0000ea  4608              MOV      r0,r1
0000ec  6840              LDR      r0,[r0,#4]
0000ee  f0200003          BIC      r0,r0,#3
0000f2  1c80              ADDS     r0,r0,#2
0000f4  6048              STR      r0,[r1,#4]
;;;62         while((uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS)) != RCC_CFGR_SWS_PLL);
0000f6  bf00              NOP      
                  |L2.248|
0000f8  480b              LDR      r0,|L2.296|
0000fa  6840              LDR      r0,[r0,#4]
0000fc  f000000c          AND      r0,r0,#0xc
000100  2808              CMP      r0,#8
000102  d1f9              BNE      |L2.248|
;;;63     
;;;64     
;;;65         SysTick->LOAD  = (uint32_t)((72000000 / 1000U) - 1UL);  // 倒数到0， 重新装载
000104  480d              LDR      r0,|L2.316|
000106  f04f21e0          MOV      r1,#0xe000e000
00010a  6148              STR      r0,[r1,#0x14]
;;;66         SysTick->VAL   = 0UL;   // current值  写入清0
00010c  2000              MOVS     r0,#0
00010e  6188              STR      r0,[r1,#0x18]
;;;67         SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |      // 1 : 内核时钟源 FCLK
000110  2005              MOVS     r0,#5
000112  6108              STR      r0,[r1,#0x10]
;;;68                         SysTick_CTRL_ENABLE_Msk;  // 定时器使能
;;;69     
;;;70     
;;;71         SET_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
000114  4608              MOV      r0,r1
000116  6900              LDR      r0,[r0,#0x10]
000118  f0400004          ORR      r0,r0,#4
00011c  6108              STR      r0,[r1,#0x10]
;;;72         SystemCoreClock = 72000000;
00011e  4808              LDR      r0,|L2.320|
000120  4908              LDR      r1,|L2.324|
000122  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;73     } 
000124  bd08              POP      {r3,pc}
;;;74     
                          ENDP

000126  0000              DCW      0x0000
                  |L2.296|
                          DCD      0x40021000
                  |L2.300|
                          DCD      0xe000ed0c
                  |L2.304|
                          DCD      0x05fa0000
                  |L2.308|
                          DCD      0x40010000
                  |L2.312|
                          DCD      0x40022000
                  |L2.316|
                          DCD      0x0001193f
                  |L2.320|
                          DCD      0x044aa200
                  |L2.324|
                          DCD      SystemCoreClock

                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM2_IRQHandler PROC
;;;141    
;;;142    void TIM2_IRQHandler(void)
000000  f04f4080          MOV      r0,#0x40000000
;;;143    {
;;;144        static uint8_t flag = 0;
;;;145    		if(TIM2->SR & (1<<0))      //溢出中断
000004  6900              LDR      r0,[r0,#0x10]
000006  f0000001          AND      r0,r0,#1
00000a  b1e8              CBZ      r0,|L3.72|
;;;146        {
;;;147            TIM2->SR &= ~(1<<0);  //清除中断标志位
00000c  f04f4080          MOV      r0,#0x40000000
000010  6900              LDR      r0,[r0,#0x10]
000012  f0200001          BIC      r0,r0,#1
000016  f04f4180          MOV      r1,#0x40000000
00001a  6108              STR      r0,[r1,#0x10]
;;;148            //执行相应操作
;;;149            if (flag) {
00001c  480b              LDR      r0,|L3.76|
00001e  7800              LDRB     r0,[r0,#0]  ; flag
000020  b148              CBZ      r0,|L3.54|
;;;150    						flag = 0;
000022  2000              MOVS     r0,#0
000024  4909              LDR      r1,|L3.76|
000026  7008              STRB     r0,[r1,#0]
;;;151    						MODIFY_REG(Led_GPIO_Port->ODR, Led_Pin, Led_Pin);
000028  4809              LDR      r0,|L3.80|
00002a  6800              LDR      r0,[r0,#0]
00002c  f0400020          ORR      r0,r0,#0x20
000030  4907              LDR      r1,|L3.80|
000032  6008              STR      r0,[r1,#0]
000034  e008              B        |L3.72|
                  |L3.54|
;;;152    				} else {
;;;153    						MODIFY_REG(Led_GPIO_Port->ODR, Led_Pin, 0);
000036  4806              LDR      r0,|L3.80|
000038  6800              LDR      r0,[r0,#0]
00003a  f0200020          BIC      r0,r0,#0x20
00003e  4904              LDR      r1,|L3.80|
000040  6008              STR      r0,[r1,#0]
;;;154    						flag = 1;
000042  2001              MOVS     r0,#1
000044  4901              LDR      r1,|L3.76|
000046  7008              STRB     r0,[r1,#0]
                  |L3.72|
;;;155    				}
;;;156        }
;;;157    
;;;158    
;;;159    }
000048  4770              BX       lr
                          ENDP

00004a  0000              DCW      0x0000
                  |L3.76|
                          DCD      flag
                  |L3.80|
                          DCD      0x40010c0c

                          AREA ||i.TIMER_Init||, CODE, READONLY, ALIGN=2

                  TIMER_Init PROC
;;;74     
;;;75     static void TIMER_Init(TIM_TypeDef *TIMx, uint32_t Periphs, IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;76     {
;;;77     	/*
;;;78     		SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM2EN);
;;;79     		NVIC_SetPriority(TIM2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
;;;80         NVIC_EnableIRQ(TIM2_IRQn);
;;;81     
;;;82         WRITE_REG(TIM2->ARR, 2000-(TIM_CCMR1_IC1F_0 << 16U));
;;;83         WRITE_REG(TIM2->PSC, 36000-(TIM_CCMR1_IC1F_0 << 16U));
;;;84     
;;;85         //tftprintf("EGR %08x", TIM2->EGR);
;;;86         //SET_BIT(TIMx->EGR, TIM_EGR_UG);
;;;87         //tftprintf("EGR %08x", TIM2->EGR);
;;;88     
;;;89         CLEAR_BIT(TIM2->CR1, TIM_CR1_OPM);
;;;90         SET_BIT(TIM2->CR1, TIM_CR1_URS);
;;;91     	  CLEAR_BIT(TIM2->SMCR, TIM_SMCR_MSM);
;;;92     
;;;93         SET_BIT(TIM2->DIER, TIM_DIER_UIE);
;;;94     
;;;95         SET_BIT(TIM2->CR1, TIM_CR1_CEN);*/
;;;96     	//开启基本定时器6（TIM6）的时钟
;;;97     		SET_BIT(RCC->APB1ENR, Periphs);
000002  4b17              LDR      r3,|L4.96|
000004  69db              LDR      r3,[r3,#0x1c]
000006  430b              ORRS     r3,r3,r1
000008  4c15              LDR      r4,|L4.96|
00000a  61e3              STR      r3,[r4,#0x1c]
;;;98      
;;;99         /*清空计数器的值*/
;;;100        WRITE_REG(TIMx->CNT, 0);
00000c  2300              MOVS     r3,#0
00000e  6243              STR      r3,[r0,#0x24]
;;;101        WRITE_REG(TIMx->ARR, 2000-(TIM_CCMR1_IC1F_0 << 16U));
000010  4b14              LDR      r3,|L4.100|
000012  62c3              STR      r3,[r0,#0x2c]
;;;102        WRITE_REG(TIMx->PSC, 36000-(TIM_CCMR1_IC1F_0 << 16U));
000014  4b14              LDR      r3,|L4.104|
000016  6283              STR      r3,[r0,#0x28]
;;;103    
;;;104        WRITE_REG(TIMx->CR1, 0); //将控制寄存器1清空
000018  2300              MOVS     r3,#0
00001a  6003              STR      r3,[r0,#0]
;;;105    
;;;106        SET_BIT(TIMx->CR1, TIM_CR1_URS); //设置事件更新请求源
00001c  6803              LDR      r3,[r0,#0]
00001e  f0430304          ORR      r3,r3,#4
000022  6003              STR      r3,[r0,#0]
;;;107    
;;;108        /*设置无缓冲功能*/
;;;109        CLEAR_BIT(TIMx->CR1, TIM_CR1_ARPE);
000024  6803              LDR      r3,[r0,#0]
000026  f0230380          BIC      r3,r3,#0x80
00002a  6003              STR      r3,[r0,#0]
;;;110    
;;;111        /*设置循环模式*/
;;;112        CLEAR_BIT(TIMx->CR1, TIM_CR1_OPM);
00002c  6803              LDR      r3,[r0,#0]
00002e  f0230308          BIC      r3,r3,#8
000032  6003              STR      r3,[r0,#0]
;;;113    
;;;114        /*允许更新中断使能*/
;;;115        SET_BIT(TIMx->DIER, TIM_DIER_UIE);
000034  68c3              LDR      r3,[r0,#0xc]
000036  f0430301          ORR      r3,r3,#1
00003a  60c3              STR      r3,[r0,#0xc]
;;;116    
;;;117        /*使能基本定时器中断*/
;;;118        NVIC_EnableIRQ(IRQn);
00003c  bf00              NOP      
00003e  f002041f          AND      r4,r2,#0x1f
000042  2301              MOVS     r3,#1
000044  40a3              LSLS     r3,r3,r4
000046  0954              LSRS     r4,r2,#5
000048  00a4              LSLS     r4,r4,#2
00004a  f10424e0          ADD      r4,r4,#0xe000e000
00004e  f8c43100          STR      r3,[r4,#0x100]
000052  bf00              NOP      
;;;119    
;;;120        /*开启计数器使能*/
;;;121        SET_BIT(TIMx->CR1, TIM_CR1_CEN);
000054  6803              LDR      r3,[r0,#0]
000056  f0430301          ORR      r3,r3,#1
00005a  6003              STR      r3,[r0,#0]
;;;122    
;;;123    }
00005c  bd10              POP      {r4,pc}
;;;124    
                          ENDP

00005e  0000              DCW      0x0000
                  |L4.96|
                          DCD      0x40021000
                  |L4.100|
                          DCD      0xfff007d0
                  |L4.104|
                          DCD      0xfff08ca0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;124    
;;;125    int main()
000000  2400              MOVS     r4,#0
;;;126    {
;;;127    	  uint8_t buf = 0;
;;;128    	
;;;129    	  RCC_Init();
000002  f7fffffe          BL       RCC_Init
;;;130        GPIO_Init();
000006  f7fffffe          BL       GPIO_Init
;;;131    	  USART_Init();
00000a  f7fffffe          BL       USART_Init
;;;132    	  TIMER_Init(TIM2, RCC_APB1ENR_TIM2EN, TIM2_IRQn);
00000e  221c              MOVS     r2,#0x1c
000010  2101              MOVS     r1,#1
000012  0788              LSLS     r0,r1,#30
000014  f7fffffe          BL       TIMER_Init
;;;133    	
;;;134        while(1) {
000018  e00b              B        |L5.50|
                  |L5.26|
;;;135    				if((USART1->SR & USART_CR1_RXNEIE) != 0) {
00001a  4806              LDR      r0,|L5.52|
00001c  6800              LDR      r0,[r0,#0]
00001e  f0000020          AND      r0,r0,#0x20
000022  b130              CBZ      r0,|L5.50|
;;;136    				    buf = USART1->DR;
000024  4803              LDR      r0,|L5.52|
000026  1d00              ADDS     r0,r0,#4
000028  6800              LDR      r0,[r0,#0]
00002a  b2c4              UXTB     r4,r0
;;;137    					  USART_RxProcess(buf);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       USART_RxProcess
                  |L5.50|
000032  e7f2              B        |L5.26|
;;;138    				}
;;;139    		}
;;;140    }
;;;141    
                          ENDP

                  |L5.52|
                          DCD      0x40013800

                          AREA ||.data||, DATA, ALIGN=0

                  flag
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "Core\\Src\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REV16|
#line 388 ".\\Core\\Inc\\cmsis_armcc.h"
|__asm___6_main_c_main____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REVSH|
#line 402
|__asm___6_main_c_main____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____RRX|
#line 587
|__asm___6_main_c_main____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
