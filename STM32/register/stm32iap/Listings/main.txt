; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\main.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\Core\Inc -IC:\workspace\CLearning\STM32\register\stm32iap\RTE\_stm32iap -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DSTM32F10X_HD -DSTM32F103xE --omf_browse=.\objects\main.crf Core\Src\main.c]
                          THUMB

                          AREA ||i.Error_Handler||, CODE, READONLY, ALIGN=1

                  Error_Handler PROC
;;;4      
;;;5      static void Error_Handler(void)
000000  4770              BX       lr
;;;6      {
;;;7      
;;;8      }
;;;9      
                          ENDP


                          AREA ||i.RCC_Init||, CODE, READONLY, ALIGN=2

                  RCC_Init PROC
;;;9      
;;;10     static void RCC_Init(void)
000000  b508              PUSH     {r3,lr}
;;;11     {
;;;12         __IO uint32_t tmpreg;
;;;13         // 辅助功能IO时钟使能
;;;14         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
000002  4849              LDR      r0,|L2.296|
000004  6980              LDR      r0,[r0,#0x18]
000006  f0400001          ORR      r0,r0,#1
00000a  4947              LDR      r1,|L2.296|
00000c  6188              STR      r0,[r1,#0x18]
;;;15         /* Delay after an RCC peripheral clock enabling */
;;;16         tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
00000e  4608              MOV      r0,r1
000010  6980              LDR      r0,[r0,#0x18]
000012  f0000001          AND      r0,r0,#1
000016  9000              STR      r0,[sp,#0]
;;;17         (void)tmpreg;
000018  bf00              NOP      
;;;18     
;;;19         // 电源接口时钟使能
;;;20         // If you don't set the RCC_APB1ENR .PWREN bit,
;;;21         // the registers of PWR unit can't be written and reading them returns 0.
;;;22         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
00001a  4608              MOV      r0,r1
00001c  69c0              LDR      r0,[r0,#0x1c]
00001e  f0405080          ORR      r0,r0,#0x10000000
000022  61c8              STR      r0,[r1,#0x1c]
;;;23         /* Delay after an RCC peripheral clock enabling */
;;;24         tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
000024  4608              MOV      r0,r1
000026  69c0              LDR      r0,[r0,#0x1c]
000028  f0005080          AND      r0,r0,#0x10000000
00002c  9000              STR      r0,[sp,#0]
;;;25         (void)tmpreg;
00002e  bf00              NOP      
;;;26     
;;;27         NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
000030  2003              MOVS     r0,#3
000032  4602              MOV      r2,r0
000034  4b3d              LDR      r3,|L2.300|
000036  6819              LDR      r1,[r3,#0]
000038  f64f03ff          MOV      r3,#0xf8ff
00003c  4019              ANDS     r1,r1,r3
00003e  4b3c              LDR      r3,|L2.304|
000040  430b              ORRS     r3,r3,r1
000042  ea432102          ORR      r1,r3,r2,LSL #8
000046  4b39              LDR      r3,|L2.300|
000048  6019              STR      r1,[r3,#0]
00004a  bf00              NOP      
;;;28     
;;;29         // 通用和复用功能I/O
;;;30         CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);  // 000：完全SWJ(JTAG-DP + SW-DP)：复位状态；
00004c  4839              LDR      r0,|L2.308|
00004e  6840              LDR      r0,[r0,#4]
000050  f02060e0          BIC      r0,r0,#0x7000000
000054  4937              LDR      r1,|L2.308|
000056  6048              STR      r0,[r1,#4]
;;;31         SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_DISABLE); // 100：关闭JTAG-DP，关闭SW-DP；
000058  4608              MOV      r0,r1
00005a  6840              LDR      r0,[r0,#4]
00005c  f0406080          ORR      r0,r0,#0x4000000
000060  6048              STR      r0,[r1,#4]
;;;32     
;;;33         // 010：两个等待状态，当 48MHz < SYSCLK ≤ 72MHz
;;;34         MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, FLASH_ACR_LATENCY_1);
000062  4835              LDR      r0,|L2.312|
000064  6800              LDR      r0,[r0,#0]
000066  f0200007          BIC      r0,r0,#7
00006a  1c80              ADDS     r0,r0,#2
00006c  4932              LDR      r1,|L2.312|
00006e  6008              STR      r0,[r1,#0]
;;;35         if((uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY)) != FLASH_ACR_LATENCY_1) {
000070  4608              MOV      r0,r1
000072  6800              LDR      r0,[r0,#0]
000074  f0000007          AND      r0,r0,#7
000078  2802              CMP      r0,#2
00007a  d001              BEQ      |L2.128|
;;;36             Error_Handler();  
00007c  f7fffffe          BL       Error_Handler
                  |L2.128|
;;;37         }
;;;38     
;;;39         // 外部高速时钟使能
;;;40         // 1： HSE振荡器开启
;;;41         SET_BIT(RCC->CR, RCC_CR_HSEON);
000080  4829              LDR      r0,|L2.296|
000082  6800              LDR      r0,[r0,#0]
000084  f4403080          ORR      r0,r0,#0x10000
000088  4927              LDR      r1,|L2.296|
00008a  6008              STR      r0,[r1,#0]
;;;42         while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RCC_CR_HSERDY);
00008c  bf00              NOP      
                  |L2.142|
00008e  4826              LDR      r0,|L2.296|
000090  6800              LDR      r0,[r0,#0]
000092  f4003000          AND      r0,r0,#0x20000
000096  f5b03f00          CMP      r0,#0x20000
00009a  d1f8              BNE      |L2.142|
;;;43     
;;;44         // PLL输入时钟源  1： PREDIV1输出作为PLL输入时钟
;;;45         // PREDIV1分频因子的低位  置0
;;;46         // PLL倍频系数  0111： PLL 9倍频输出
;;;47         MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
00009c  4822              LDR      r0,|L2.296|
00009e  6840              LDR      r0,[r0,#4]
0000a0  f420107c          BIC      r0,r0,#0x3f0000
0000a4  f44010e8          ORR      r0,r0,#0x1d0000
0000a8  491f              LDR      r1,|L2.296|
0000aa  6048              STR      r0,[r1,#4]
;;;48                  (RCC_CFGR_PLLSRC & (RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE)) | RCC_CFGR_PLLMULL9);
;;;49     
;;;50         // 1： PLL使能。
;;;51         SET_BIT(RCC->CR, RCC_CR_PLLON);
0000ac  4608              MOV      r0,r1
0000ae  6800              LDR      r0,[r0,#0]
0000b0  f0407080          ORR      r0,r0,#0x1000000
0000b4  6008              STR      r0,[r1,#0]
;;;52         while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RCC_CR_PLLRDY);
0000b6  bf00              NOP      
                  |L2.184|
0000b8  481b              LDR      r0,|L2.296|
0000ba  6800              LDR      r0,[r0,#0]
0000bc  f0007000          AND      r0,r0,#0x2000000
0000c0  f1b07f00          CMP      r0,#0x2000000
0000c4  d1f8              BNE      |L2.184|
;;;53     
;;;54         // AHB预分频  0xxx： SYSCLK不分频
;;;55         MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_CFGR_HPRE_DIV1);
0000c6  4818              LDR      r0,|L2.296|
0000c8  6840              LDR      r0,[r0,#4]
0000ca  f02000f0          BIC      r0,r0,#0xf0
0000ce  4916              LDR      r1,|L2.296|
0000d0  6048              STR      r0,[r1,#4]
;;;56         // 低速APB预分频   100： HCLK 2分频
;;;57         MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV2);
0000d2  4608              MOV      r0,r1
0000d4  6840              LDR      r0,[r0,#4]
0000d6  f42060e0          BIC      r0,r0,#0x700
0000da  f4406080          ORR      r0,r0,#0x400
0000de  6048              STR      r0,[r1,#4]
;;;58         // 高速APB预分频   0xx： HCLK不分频
;;;59         MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_CFGR_PPRE2_DIV1);
0000e0  4608              MOV      r0,r1
0000e2  6840              LDR      r0,[r0,#4]
0000e4  f4205060          BIC      r0,r0,#0x3800
0000e8  6048              STR      r0,[r1,#4]
;;;60         // 系统时钟切换    10： PLL输出作为系统时钟；
;;;61         MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);
0000ea  4608              MOV      r0,r1
0000ec  6840              LDR      r0,[r0,#4]
0000ee  f0200003          BIC      r0,r0,#3
0000f2  1c80              ADDS     r0,r0,#2
0000f4  6048              STR      r0,[r1,#4]
;;;62         while((uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS)) != RCC_CFGR_SWS_PLL);
0000f6  bf00              NOP      
                  |L2.248|
0000f8  480b              LDR      r0,|L2.296|
0000fa  6840              LDR      r0,[r0,#4]
0000fc  f000000c          AND      r0,r0,#0xc
000100  2808              CMP      r0,#8
000102  d1f9              BNE      |L2.248|
;;;63     
;;;64     
;;;65         SysTick->LOAD  = (uint32_t)((72000000 / 1000U) - 1UL);  // 倒数到0， 重新装载
000104  480d              LDR      r0,|L2.316|
000106  f04f21e0          MOV      r1,#0xe000e000
00010a  6148              STR      r0,[r1,#0x14]
;;;66         SysTick->VAL   = 0UL;   // current值  写入清0
00010c  2000              MOVS     r0,#0
00010e  6188              STR      r0,[r1,#0x18]
;;;67         SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |      // 1 : 内核时钟源 FCLK
000110  2005              MOVS     r0,#5
000112  6108              STR      r0,[r1,#0x10]
;;;68                         SysTick_CTRL_ENABLE_Msk;  // 定时器使能
;;;69     
;;;70     
;;;71         SET_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
000114  4608              MOV      r0,r1
000116  6900              LDR      r0,[r0,#0x10]
000118  f0400004          ORR      r0,r0,#4
00011c  6108              STR      r0,[r1,#0x10]
;;;72         SystemCoreClock = 72000000;
00011e  4808              LDR      r0,|L2.320|
000120  4908              LDR      r1,|L2.324|
000122  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;73     } 
000124  bd08              POP      {r3,pc}
;;;74     
                          ENDP

000126  0000              DCW      0x0000
                  |L2.296|
                          DCD      0x40021000
                  |L2.300|
                          DCD      0xe000ed0c
                  |L2.304|
                          DCD      0x05fa0000
                  |L2.308|
                          DCD      0x40010000
                  |L2.312|
                          DCD      0x40022000
                  |L2.316|
                          DCD      0x0001193f
                  |L2.320|
                          DCD      0x044aa200
                  |L2.324|
                          DCD      SystemCoreClock

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;74     
;;;75     int main()
000000  2400              MOVS     r4,#0
;;;76     {
;;;77     	  uint8_t buf = 0;
;;;78     	
;;;79     	  RCC_Init();
000002  f7fffffe          BL       RCC_Init
;;;80         GPIO_Init();
000006  f7fffffe          BL       GPIO_Init
;;;81     	  USART_Init();
00000a  f7fffffe          BL       USART_Init
;;;82     	
;;;83         while(1) {
00000e  e00b              B        |L3.40|
                  |L3.16|
;;;84     				if((USART1->SR & USART_CR1_RXNEIE) != 0) {
000010  4806              LDR      r0,|L3.44|
000012  6800              LDR      r0,[r0,#0]
000014  f0000020          AND      r0,r0,#0x20
000018  b130              CBZ      r0,|L3.40|
;;;85     				    buf = USART1->DR;
00001a  4804              LDR      r0,|L3.44|
00001c  1d00              ADDS     r0,r0,#4
00001e  6800              LDR      r0,[r0,#0]
000020  b2c4              UXTB     r4,r0
;;;86     					  USART_RxProcess(buf);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       USART_RxProcess
                  |L3.40|
000028  e7f2              B        |L3.16|
;;;87     				}
;;;88     		}
;;;89     }
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x40013800

;*** Start embedded assembler ***

#line 1 "Core\\Src\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REV16|
#line 388 ".\\Core\\Inc\\cmsis_armcc.h"
|__asm___6_main_c_main____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REVSH|
#line 402
|__asm___6_main_c_main____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____RRX|
#line 587
|__asm___6_main_c_main____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
