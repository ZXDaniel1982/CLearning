; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\main.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\inc -IC:\workspace\CLearning\STM32\register\stm32iap\RTE\_stm32iap -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.3.0\Device\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DSTM32F10X_HD -DSTM32F103xE --omf_browse=.\objects\main.crf src\main.c]
                          THUMB

                          AREA ||i.Error_Handler||, CODE, READONLY, ALIGN=1

                  Error_Handler PROC
;;;4      
;;;5      static void Error_Handler(void)
000000  4770              BX       lr
;;;6      {
;;;7      
;;;8      }
;;;9      
                          ENDP


                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;74     
;;;75     static void GPIO_Init()
000000  b508              PUSH     {r3,lr}
;;;76     {
;;;77         __IO uint32_t tmpreg;
;;;78     
;;;79         // IO端口B时钟使能
;;;80         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPBEN);
000002  4818              LDR      r0,|L2.100|
000004  6980              LDR      r0,[r0,#0x18]
000006  f0400008          ORR      r0,r0,#8
00000a  4916              LDR      r1,|L2.100|
00000c  6188              STR      r0,[r1,#0x18]
;;;81         /* Delay after an RCC peripheral clock enabling */
;;;82         tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPBEN);
00000e  4608              MOV      r0,r1
000010  6980              LDR      r0,[r0,#0x18]
000012  f0000008          AND      r0,r0,#8
000016  9000              STR      r0,[sp,#0]
;;;83         (void)tmpreg;
000018  bf00              NOP      
;;;84     
;;;85         // 端口位清除寄存器  清除端口x的位y  1：清除对应的ODRy位为0
;;;86         WRITE_REG(Led_GPIO_Port->BRR, Led_Pin);
00001a  2020              MOVS     r0,#0x20
00001c  4912              LDR      r1,|L2.104|
00001e  6008              STR      r0,[r1,#0]
;;;87     
;;;88         // 端口配置低寄存器  CNF 00：通用推挽输出模式  MODE  01：输出模式，最大速度10MHz
;;;89         MODIFY_REG(Led_GPIO_Port->CRL, (GPIO_CRL_CNF5 | GPIO_CRL_MODE5), GPIO_CRL_MODE5_0);
000020  4811              LDR      r0,|L2.104|
000022  3814              SUBS     r0,r0,#0x14
000024  6800              LDR      r0,[r0,#0]
000026  f4200070          BIC      r0,r0,#0xf00000
00002a  f4401080          ORR      r0,r0,#0x100000
00002e  490e              LDR      r1,|L2.104|
000030  3914              SUBS     r1,r1,#0x14
000032  6008              STR      r0,[r1,#0]
;;;90     
;;;91         // 端口输出数据寄存器  
;;;92         MODIFY_REG(Led_GPIO_Port->ODR, Led_Pin, 0);
000034  480c              LDR      r0,|L2.104|
000036  3808              SUBS     r0,r0,#8
000038  6800              LDR      r0,[r0,#0]
00003a  f0200020          BIC      r0,r0,#0x20
00003e  490a              LDR      r1,|L2.104|
000040  3908              SUBS     r1,r1,#8
000042  6008              STR      r0,[r1,#0]
;;;93     
;;;94         //  11：输出模式，最大速度50MHz
;;;95         MODIFY_REG(Led_GPIO_Port->CRL, GPIO_CRL_MODE5, GPIO_CRL_MODE5_1);
000044  4808              LDR      r0,|L2.104|
000046  3814              SUBS     r0,r0,#0x14
000048  6800              LDR      r0,[r0,#0]
00004a  f4201040          BIC      r0,r0,#0x300000
00004e  f4401000          ORR      r0,r0,#0x200000
000052  4905              LDR      r1,|L2.104|
000054  3914              SUBS     r1,r1,#0x14
000056  6008              STR      r0,[r1,#0]
;;;96     
;;;97         // 00：通用推挽输出模式
;;;98         MODIFY_REG(Led_GPIO_Port->CRL, GPIO_CRL_CNF5_0, 0);
000058  4608              MOV      r0,r1
00005a  6800              LDR      r0,[r0,#0]
00005c  f4200080          BIC      r0,r0,#0x400000
000060  6008              STR      r0,[r1,#0]
;;;99     }
000062  bd08              POP      {r3,pc}
;;;100    
                          ENDP

                  |L2.100|
                          DCD      0x40021000
                  |L2.104|
                          DCD      0x40010c14

                          AREA ||i.RCC_Init||, CODE, READONLY, ALIGN=2

                  RCC_Init PROC
;;;9      
;;;10     static void RCC_Init(void)
000000  b508              PUSH     {r3,lr}
;;;11     {
;;;12         __IO uint32_t tmpreg;
;;;13         // 辅助功能IO时钟使能
;;;14         SET_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
000002  4849              LDR      r0,|L3.296|
000004  6980              LDR      r0,[r0,#0x18]
000006  f0400001          ORR      r0,r0,#1
00000a  4947              LDR      r1,|L3.296|
00000c  6188              STR      r0,[r1,#0x18]
;;;15         /* Delay after an RCC peripheral clock enabling */
;;;16         tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
00000e  4608              MOV      r0,r1
000010  6980              LDR      r0,[r0,#0x18]
000012  f0000001          AND      r0,r0,#1
000016  9000              STR      r0,[sp,#0]
;;;17         (void)tmpreg;
000018  bf00              NOP      
;;;18     
;;;19         // 电源接口时钟使能
;;;20         // If you don't set the RCC_APB1ENR .PWREN bit,
;;;21         // the registers of PWR unit can't be written and reading them returns 0.
;;;22         SET_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
00001a  4608              MOV      r0,r1
00001c  69c0              LDR      r0,[r0,#0x1c]
00001e  f0405080          ORR      r0,r0,#0x10000000
000022  61c8              STR      r0,[r1,#0x1c]
;;;23         /* Delay after an RCC peripheral clock enabling */
;;;24         tmpreg = READ_BIT(RCC->APB1ENR, RCC_APB1ENR_PWREN);
000024  4608              MOV      r0,r1
000026  69c0              LDR      r0,[r0,#0x1c]
000028  f0005080          AND      r0,r0,#0x10000000
00002c  9000              STR      r0,[sp,#0]
;;;25         (void)tmpreg;
00002e  bf00              NOP      
;;;26     
;;;27         NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
000030  2003              MOVS     r0,#3
000032  4602              MOV      r2,r0
000034  4b3d              LDR      r3,|L3.300|
000036  6819              LDR      r1,[r3,#0]
000038  f64f03ff          MOV      r3,#0xf8ff
00003c  4019              ANDS     r1,r1,r3
00003e  4b3c              LDR      r3,|L3.304|
000040  430b              ORRS     r3,r3,r1
000042  ea432102          ORR      r1,r3,r2,LSL #8
000046  4b39              LDR      r3,|L3.300|
000048  6019              STR      r1,[r3,#0]
00004a  bf00              NOP      
;;;28     
;;;29         // 通用和复用功能I/O
;;;30         CLEAR_BIT(AFIO->MAPR,AFIO_MAPR_SWJ_CFG);  // 000：完全SWJ(JTAG-DP + SW-DP)：复位状态；
00004c  4839              LDR      r0,|L3.308|
00004e  6840              LDR      r0,[r0,#4]
000050  f02060e0          BIC      r0,r0,#0x7000000
000054  4937              LDR      r1,|L3.308|
000056  6048              STR      r0,[r1,#4]
;;;31         SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_DISABLE); // 100：关闭JTAG-DP，关闭SW-DP；
000058  4608              MOV      r0,r1
00005a  6840              LDR      r0,[r0,#4]
00005c  f0406080          ORR      r0,r0,#0x4000000
000060  6048              STR      r0,[r1,#4]
;;;32     
;;;33         // 010：两个等待状态，当 48MHz < SYSCLK ≤ 72MHz
;;;34         MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, FLASH_ACR_LATENCY_1);
000062  4835              LDR      r0,|L3.312|
000064  6800              LDR      r0,[r0,#0]
000066  f0200007          BIC      r0,r0,#7
00006a  1c80              ADDS     r0,r0,#2
00006c  4932              LDR      r1,|L3.312|
00006e  6008              STR      r0,[r1,#0]
;;;35         if((uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY)) != FLASH_ACR_LATENCY_1) {
000070  4608              MOV      r0,r1
000072  6800              LDR      r0,[r0,#0]
000074  f0000007          AND      r0,r0,#7
000078  2802              CMP      r0,#2
00007a  d001              BEQ      |L3.128|
;;;36             Error_Handler();  
00007c  f7fffffe          BL       Error_Handler
                  |L3.128|
;;;37         }
;;;38     
;;;39         // 外部高速时钟使能
;;;40         // 1： HSE振荡器开启
;;;41         SET_BIT(RCC->CR, RCC_CR_HSEON);
000080  4829              LDR      r0,|L3.296|
000082  6800              LDR      r0,[r0,#0]
000084  f4403080          ORR      r0,r0,#0x10000
000088  4927              LDR      r1,|L3.296|
00008a  6008              STR      r0,[r1,#0]
;;;42         while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RCC_CR_HSERDY);
00008c  bf00              NOP      
                  |L3.142|
00008e  4826              LDR      r0,|L3.296|
000090  6800              LDR      r0,[r0,#0]
000092  f4003000          AND      r0,r0,#0x20000
000096  f5b03f00          CMP      r0,#0x20000
00009a  d1f8              BNE      |L3.142|
;;;43     
;;;44         // PLL输入时钟源  1： PREDIV1输出作为PLL输入时钟
;;;45         // PREDIV1分频因子的低位  置0
;;;46         // PLL倍频系数  0111： PLL 9倍频输出
;;;47         MODIFY_REG(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL,
00009c  4822              LDR      r0,|L3.296|
00009e  6840              LDR      r0,[r0,#4]
0000a0  f420107c          BIC      r0,r0,#0x3f0000
0000a4  f44010e8          ORR      r0,r0,#0x1d0000
0000a8  491f              LDR      r1,|L3.296|
0000aa  6048              STR      r0,[r1,#4]
;;;48                  (RCC_CFGR_PLLSRC & (RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE)) | RCC_CFGR_PLLMULL9);
;;;49     
;;;50         // 1： PLL使能。
;;;51         SET_BIT(RCC->CR, RCC_CR_PLLON);
0000ac  4608              MOV      r0,r1
0000ae  6800              LDR      r0,[r0,#0]
0000b0  f0407080          ORR      r0,r0,#0x1000000
0000b4  6008              STR      r0,[r1,#0]
;;;52         while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RCC_CR_PLLRDY);
0000b6  bf00              NOP      
                  |L3.184|
0000b8  481b              LDR      r0,|L3.296|
0000ba  6800              LDR      r0,[r0,#0]
0000bc  f0007000          AND      r0,r0,#0x2000000
0000c0  f1b07f00          CMP      r0,#0x2000000
0000c4  d1f8              BNE      |L3.184|
;;;53     
;;;54         // AHB预分频  0xxx： SYSCLK不分频
;;;55         MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_CFGR_HPRE_DIV1);
0000c6  4818              LDR      r0,|L3.296|
0000c8  6840              LDR      r0,[r0,#4]
0000ca  f02000f0          BIC      r0,r0,#0xf0
0000ce  4916              LDR      r1,|L3.296|
0000d0  6048              STR      r0,[r1,#4]
;;;56         // 低速APB预分频   100： HCLK 2分频
;;;57         MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_CFGR_PPRE1_DIV2);
0000d2  4608              MOV      r0,r1
0000d4  6840              LDR      r0,[r0,#4]
0000d6  f42060e0          BIC      r0,r0,#0x700
0000da  f4406080          ORR      r0,r0,#0x400
0000de  6048              STR      r0,[r1,#4]
;;;58         // 高速APB预分频   0xx： HCLK不分频
;;;59         MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_CFGR_PPRE2_DIV1);
0000e0  4608              MOV      r0,r1
0000e2  6840              LDR      r0,[r0,#4]
0000e4  f4205060          BIC      r0,r0,#0x3800
0000e8  6048              STR      r0,[r1,#4]
;;;60         // 系统时钟切换    10： PLL输出作为系统时钟；
;;;61         MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_CFGR_SW_PLL);
0000ea  4608              MOV      r0,r1
0000ec  6840              LDR      r0,[r0,#4]
0000ee  f0200003          BIC      r0,r0,#3
0000f2  1c80              ADDS     r0,r0,#2
0000f4  6048              STR      r0,[r1,#4]
;;;62         while((uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS)) != RCC_CFGR_SWS_PLL);
0000f6  bf00              NOP      
                  |L3.248|
0000f8  480b              LDR      r0,|L3.296|
0000fa  6840              LDR      r0,[r0,#4]
0000fc  f000000c          AND      r0,r0,#0xc
000100  2808              CMP      r0,#8
000102  d1f9              BNE      |L3.248|
;;;63     
;;;64     
;;;65         SysTick->LOAD  = (uint32_t)((72000000 / 1000U) - 1UL);  // 倒数到0， 重新装载
000104  480d              LDR      r0,|L3.316|
000106  f04f21e0          MOV      r1,#0xe000e000
00010a  6148              STR      r0,[r1,#0x14]
;;;66         SysTick->VAL   = 0UL;   // current值  写入清0
00010c  2000              MOVS     r0,#0
00010e  6188              STR      r0,[r1,#0x18]
;;;67         SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |      // 1 : 内核时钟源 FCLK
000110  2005              MOVS     r0,#5
000112  6108              STR      r0,[r1,#0x10]
;;;68                         SysTick_CTRL_ENABLE_Msk;  // 定时器使能
;;;69     
;;;70     
;;;71         SET_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk);
000114  4608              MOV      r0,r1
000116  6900              LDR      r0,[r0,#0x10]
000118  f0400004          ORR      r0,r0,#4
00011c  6108              STR      r0,[r1,#0x10]
;;;72         SystemCoreClock = 72000000;
00011e  4808              LDR      r0,|L3.320|
000120  4908              LDR      r1,|L3.324|
000122  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;73     } 
000124  bd08              POP      {r3,pc}
;;;74     
                          ENDP

000126  0000              DCW      0x0000
                  |L3.296|
                          DCD      0x40021000
                  |L3.300|
                          DCD      0xe000ed0c
                  |L3.304|
                          DCD      0x05fa0000
                  |L3.308|
                          DCD      0x40010000
                  |L3.312|
                          DCD      0x40022000
                  |L3.316|
                          DCD      0x0001193f
                  |L3.320|
                          DCD      0x044aa200
                  |L3.324|
                          DCD      SystemCoreClock

                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;100    
;;;101    static void USART_Init()
000000  b508              PUSH     {r3,lr}
;;;102    {
;;;103        __IO uint32_t tmpreg;
;;;104        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);
000002  4841              LDR      r0,|L4.264|
000004  6980              LDR      r0,[r0,#0x18]
000006  f4404080          ORR      r0,r0,#0x4000
00000a  493f              LDR      r1,|L4.264|
00000c  6188              STR      r0,[r1,#0x18]
;;;105        /* Delay after an RCC peripheral clock enabling */
;;;106        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_USART1EN);
00000e  4608              MOV      r0,r1
000010  6980              LDR      r0,[r0,#0x18]
000012  f4004080          AND      r0,r0,#0x4000
000016  9000              STR      r0,[sp,#0]
;;;107        (void)tmpreg;
000018  bf00              NOP      
;;;108    
;;;109        tmpreg;
00001a  bf00              NOP      
;;;110        SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN);
00001c  4608              MOV      r0,r1
00001e  6980              LDR      r0,[r0,#0x18]
000020  f0400004          ORR      r0,r0,#4
000024  6188              STR      r0,[r1,#0x18]
;;;111        /* Delay after an RCC peripheral clock enabling */
;;;112        tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN);
000026  4608              MOV      r0,r1
000028  6980              LDR      r0,[r0,#0x18]
00002a  f0000004          AND      r0,r0,#4
00002e  9000              STR      r0,[sp,#0]
;;;113        (void)tmpreg;
000030  bf00              NOP      
;;;114    
;;;115        // 端口配置低寄存器  CNF 00：通用推挽输出模式  MODE  01：输出模式，最大速度10MHz
;;;116        MODIFY_REG(GPIOA->CRH, (GPIO_CRH_CNF9 | GPIO_CRH_MODE9), (GPIO_CRH_CNF9_1 | GPIO_CRH_MODE9));
000032  4836              LDR      r0,|L4.268|
000034  6800              LDR      r0,[r0,#0]
000036  f02000f0          BIC      r0,r0,#0xf0
00003a  f04000b0          ORR      r0,r0,#0xb0
00003e  4933              LDR      r1,|L4.268|
000040  6008              STR      r0,[r1,#0]
;;;117    
;;;118        // 端口输出数据寄存器  
;;;119        MODIFY_REG(GPIOA->ODR, GPIO_BSRR_BS9, 0);
000042  4832              LDR      r0,|L4.268|
000044  3008              ADDS     r0,r0,#8
000046  6800              LDR      r0,[r0,#0]
000048  f4207000          BIC      r0,r0,#0x200
00004c  492f              LDR      r1,|L4.268|
00004e  3108              ADDS     r1,r1,#8
000050  6008              STR      r0,[r1,#0]
;;;120    
;;;121        //  11：输出模式，最大速度50MHz
;;;122        MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE9, GPIO_CRH_MODE9);
000052  482e              LDR      r0,|L4.268|
000054  6800              LDR      r0,[r0,#0]
000056  f0400030          ORR      r0,r0,#0x30
00005a  492c              LDR      r1,|L4.268|
00005c  6008              STR      r0,[r1,#0]
;;;123    
;;;124        // 00：通用推挽输出模式
;;;125        MODIFY_REG(GPIOA->CRH, GPIO_CRH_CNF9_0, 0);
00005e  4608              MOV      r0,r1
000060  6800              LDR      r0,[r0,#0]
000062  f0200040          BIC      r0,r0,#0x40
000066  6008              STR      r0,[r1,#0]
;;;126    
;;;127        // 端口配置低寄存器  CNF 00：通用推挽输出模式  MODE  01：输出模式，最大速度10MHz
;;;128        MODIFY_REG(GPIOA->CRH, (GPIO_CRH_CNF10 | GPIO_CRH_MODE10), GPIO_CRH_CNF10_0);
000068  4608              MOV      r0,r1
00006a  6800              LDR      r0,[r0,#0]
00006c  f4206070          BIC      r0,r0,#0xf00
000070  f4406080          ORR      r0,r0,#0x400
000074  6008              STR      r0,[r1,#0]
;;;129    
;;;130        // 端口输出数据寄存器  
;;;131        MODIFY_REG(GPIOA->ODR, GPIO_BSRR_BS10, 0);
000076  4825              LDR      r0,|L4.268|
000078  3008              ADDS     r0,r0,#8
00007a  6800              LDR      r0,[r0,#0]
00007c  f4206080          BIC      r0,r0,#0x400
000080  4922              LDR      r1,|L4.268|
000082  3108              ADDS     r1,r1,#8
000084  6008              STR      r0,[r1,#0]
;;;132    
;;;133        //  11：输出模式，最大速度50MHz
;;;134        MODIFY_REG(GPIOA->CRH, GPIO_CRH_MODE10, 0);
000086  4821              LDR      r0,|L4.268|
000088  6800              LDR      r0,[r0,#0]
00008a  f4207040          BIC      r0,r0,#0x300
00008e  491f              LDR      r1,|L4.268|
000090  6008              STR      r0,[r1,#0]
;;;135    
;;;136        // 00：通用推挽输出模式
;;;137        MODIFY_REG(GPIOA->CRH, GPIO_CRH_CNF10_0, GPIO_CRH_CNF10_0);
000092  4608              MOV      r0,r1
000094  6800              LDR      r0,[r0,#0]
000096  f4406080          ORR      r0,r0,#0x400
00009a  6008              STR      r0,[r1,#0]
;;;138    
;;;139        if (READ_BIT(USART1->CR1, USART_CR1_UE) != (USART_CR1_UE)) {
00009c  481c              LDR      r0,|L4.272|
00009e  6800              LDR      r0,[r0,#0]
0000a0  f4005000          AND      r0,r0,#0x2000
0000a4  f5b05f00          CMP      r0,#0x2000
0000a8  d019              BEQ      |L4.222|
;;;140            MODIFY_REG(USART1->CR1,
0000aa  4819              LDR      r0,|L4.272|
0000ac  6800              LDR      r0,[r0,#0]
0000ae  f241610c          MOV      r1,#0x160c
0000b2  4388              BICS     r0,r0,r1
0000b4  f040000c          ORR      r0,r0,#0xc
0000b8  4915              LDR      r1,|L4.272|
0000ba  6008              STR      r0,[r1,#0]
;;;141                   (USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE),
;;;142                   (USART_CR1_TE |USART_CR1_RE));
;;;143    
;;;144            MODIFY_REG(USART1->CR2, USART_CR2_STOP, 0);
0000bc  1d08              ADDS     r0,r1,#4
0000be  6800              LDR      r0,[r0,#0]
0000c0  f4205040          BIC      r0,r0,#0x3000
0000c4  1d09              ADDS     r1,r1,#4
0000c6  6008              STR      r0,[r1,#0]
;;;145    
;;;146            MODIFY_REG(USART1->CR3, USART_CR3_RTSE | USART_CR3_CTSE, 0);
0000c8  1d08              ADDS     r0,r1,#4
0000ca  6800              LDR      r0,[r0,#0]
0000cc  f4207040          BIC      r0,r0,#0x300
0000d0  1d09              ADDS     r1,r1,#4
0000d2  6008              STR      r0,[r1,#0]
;;;147    
;;;148            USART1->BRR = 0x271;
0000d4  f2402071          MOV      r0,#0x271
0000d8  490d              LDR      r1,|L4.272|
0000da  1f09              SUBS     r1,r1,#4
0000dc  6008              STR      r0,[r1,#0]
                  |L4.222|
;;;149        }
;;;150    		
;;;151    		CLEAR_BIT(USART1->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
0000de  480c              LDR      r0,|L4.272|
0000e0  1d00              ADDS     r0,r0,#4
0000e2  6800              LDR      r0,[r0,#0]
0000e4  f4204090          BIC      r0,r0,#0x4800
0000e8  4909              LDR      r1,|L4.272|
0000ea  1d09              ADDS     r1,r1,#4
0000ec  6008              STR      r0,[r1,#0]
;;;152        CLEAR_BIT(USART1->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
0000ee  1d08              ADDS     r0,r1,#4
0000f0  6800              LDR      r0,[r0,#0]
0000f2  f020002a          BIC      r0,r0,#0x2a
0000f6  1d09              ADDS     r1,r1,#4
0000f8  6008              STR      r0,[r1,#0]
;;;153    		
;;;154    		//SET_BIT(USART1->CR1, USART_CR1_UE | USART_CR1_TE | USART_CR1_RE);
;;;155    		USART1->CR1 |= USART_CR1_UE;
0000fa  4805              LDR      r0,|L4.272|
0000fc  6800              LDR      r0,[r0,#0]
0000fe  f4405000          ORR      r0,r0,#0x2000
000102  4903              LDR      r1,|L4.272|
000104  6008              STR      r0,[r1,#0]
;;;156    }
000106  bd08              POP      {r3,pc}
;;;157    
                          ENDP

                  |L4.264|
                          DCD      0x40021000
                  |L4.268|
                          DCD      0x40010804
                  |L4.272|
                          DCD      0x4001380c

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;162    //#define TEST_TX
;;;163    int main()
000000  2400              MOVS     r4,#0
;;;164    {
;;;165    	  uint32_t cnt = 0;
;;;166    	  char buf = 0;
000002  2500              MOVS     r5,#0
;;;167    	
;;;168    	  RCC_Init();
000004  f7fffffe          BL       RCC_Init
;;;169        GPIO_Init();
000008  f7fffffe          BL       GPIO_Init
;;;170    	  USART_Init();
00000c  f7fffffe          BL       USART_Init
;;;171    	
;;;172    	  
;;;173    	  //MODIFY_REG(Led_GPIO_Port->ODR, Led_Pin, GPIO_ODR_ODR5);
;;;174    	
;;;175        while(1) {
000010  e01e              B        |L5.80|
                  |L5.18|
;;;176    #ifdef TEST_TX
;;;177    		    for (cnt=0;cnt<7200000;cnt++) {}
;;;178    			  while ((USART1->SR &USART_SR_TXE) == 0) {}
;;;179    				buf = USART1->DR;
;;;180            USART1->DR= buf; 
;;;181    #else
;;;182    				if((USART1->SR & USART_CR1_RXNEIE) != 0) {
000012  4810              LDR      r0,|L5.84|
000014  6800              LDR      r0,[r0,#0]
000016  f0000020          AND      r0,r0,#0x20
00001a  b1c8              CBZ      r0,|L5.80|
;;;183    					  MODIFY_REG(Led_GPIO_Port->ODR, Led_Pin, GPIO_ODR_ODR5);
00001c  480e              LDR      r0,|L5.88|
00001e  6800              LDR      r0,[r0,#0]
000020  f0400020          ORR      r0,r0,#0x20
000024  490c              LDR      r1,|L5.88|
000026  6008              STR      r0,[r1,#0]
;;;184    				    buf = USART1->DR;
000028  480a              LDR      r0,|L5.84|
00002a  1d00              ADDS     r0,r0,#4
00002c  6800              LDR      r0,[r0,#0]
00002e  b2c5              UXTB     r5,r0
;;;185    					  for (cnt=0;cnt<7200000;cnt++) {}
000030  2400              MOVS     r4,#0
000032  e000              B        |L5.54|
                  |L5.52|
000034  1c64              ADDS     r4,r4,#1
                  |L5.54|
000036  4809              LDR      r0,|L5.92|
000038  4284              CMP      r4,r0
00003a  d3fb              BCC      |L5.52|
;;;186    					  while ((USART1->SR &USART_SR_TXE) == 0) {}
00003c  bf00              NOP      
                  |L5.62|
00003e  4805              LDR      r0,|L5.84|
000040  6800              LDR      r0,[r0,#0]
000042  f0000080          AND      r0,r0,#0x80
000046  2800              CMP      r0,#0
000048  d0f9              BEQ      |L5.62|
;;;187                USART1->DR= buf; 
00004a  4802              LDR      r0,|L5.84|
00004c  1d00              ADDS     r0,r0,#4
00004e  6005              STR      r5,[r0,#0]
                  |L5.80|
000050  e7df              B        |L5.18|
;;;188    				}
;;;189    #endif
;;;190    		}
;;;191    }
                          ENDP

000052  0000              DCW      0x0000
                  |L5.84|
                          DCD      0x40013800
                  |L5.88|
                          DCD      0x40010c0c
                  |L5.92|
                          DCD      0x006ddd00

;*** Start embedded assembler ***

#line 1 "src\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REV16|
#line 388 ".\\inc\\cmsis_armcc.h"
|__asm___6_main_c_main____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____REVSH|
#line 402
|__asm___6_main_c_main____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_main____RRX|
#line 587
|__asm___6_main_c_main____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
